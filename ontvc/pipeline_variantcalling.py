"""
=================
Pipeline variantcalling
=================


Overview
==================

This workflow processes nanopore fastq files. The aim of this pipeline
is to generate a lits of variants associated with each sample

Usage
=====

To generate the config file to change the running of the pipeline you need to
run:

ontvc variantcalling config

This will generate a pipeline.yml file that the user can modify to change the
output of the pipeline. Once the user has modified the pipeline.yml file the
pipeline can then be ran using the following commandline command:

ontvc variantcalling make full -v5

You can run the pipeline locally (without a cluster) using --local

ontvc variantcalling make full -v5 --local

Configuration
-------------

The pipeline uses CGAT-core as the pipeline language. Please see the
docuemntation for how to install ontvc.


Input files
-----------

The workflow requires the following inputs:
* a single fastq file generated by guppy basecalling

Pipeline output
==================

Code
==================
"""
import sys
import os
import pysam
import glob
import pandas as pd
from ruffus import *
import cgatcore.iotools as iotools
import cgatcore.pipeline as P
import cgatcore.experiment as E
from cgatcore.pipeline import cluster_runnable

# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])

# Determine the location of the input fastq files

try:
    PARAMS['data']
except NameError:
    DATADIR = "."
else:
    if PARAMS['data'] == 0:
        DATADIR = "."
    elif PARAMS['data'] == 1:
        DATADIR = "data.dir"
    else:
        DATADIR = PARAMS['data']


SEQUENCESUFFIXES = ("*.fastq.gz",
		    "*.fastq.1.gz")
SEQUENCEFILES = tuple([os.path.join(DATADIR, suffix_name)
                       for suffix_name in SEQUENCESUFFIXES])

@follows(mkdir("mapped.dir"))
@transform(SEQUENCEFILES,
           regex("{}/(\S+).fastq.gz".format(DATADIR)),
         r"mapped.dir/\1.sam")
def run_mapping(infile, outfile):
    '''Run minimap2 to map the data to genome'''


    statement = '''minimap2 %(minimap2_options)s %(reference_fasta)s %(infile)s > %(outfile)s'''

    P.run(statement)



@follows(run_mapping)
def full():
    pass


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))    
